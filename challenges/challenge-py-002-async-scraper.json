{
  "id": "py-async-task-scheduler",
  "metadata": {
    "title": "Async Task Scheduler with Priority Queue",
    "description": "Build an asynchronous task scheduler that manages tasks with priorities, delays, and concurrent execution limits.\n\n## Learning Objectives\n- Asyncio for concurrent task execution\n- Priority queues and task scheduling\n- Async context managers and resource management\n- Task cancellation and cleanup",
    "difficulty": "hard",
    "points": 3,
    "timeLimit": 30,
    "tags": ["python", "asyncio", "scheduling", "priority-queue", "concurrency"],
    "author": "Z-Challenge Team",
    "createdAt": "2025-10-05T11:15:00Z",
    "version": "1.0",
    "supportedLanguages": ["python"]
  },
  "problem": {
    "statement": "Create an async task scheduler that executes tasks based on priority, with support for delayed execution and concurrency limits.",
    "inputFormat": "Task definitions with priority, delay, and execution time",
    "outputFormat": "Task execution results with timestamps and completion status",
    "constraints": "- Max 3 concurrent tasks\n- Higher priority number = higher priority\n- Tasks can be delayed by specified seconds\n- Handle task failures gracefully",
    "examples": [
      {
        "input": "schedule 1 0 100\\nschedule 2 1 200\\nschedule 3 0 150\\nrun",
        "output": "Task 2 completed in 200ms\\nTask 3 completed in 150ms\\nTask 1 completed in 100ms",
        "explanation": "Tasks executed by priority (2, 3, 1) with simulated execution times"
      }
    ]
  },
  "languages": {
    "python": {
      "starterCode": "import asyncio\nimport heapq\nimport time\nfrom typing import List, Optional, Callable, Any\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass TaskStatus(Enum):\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n\n@dataclass\nclass Task:\n    id: int\n    priority: int\n    delay: float\n    execution_time: int  # milliseconds\n    status: TaskStatus = TaskStatus.PENDING\n    result: Any = None\n    \n    def __lt__(self, other):\n        # Higher priority number = higher priority (reverse order for min-heap)\n        return self.priority > other.priority\n\nclass AsyncTaskScheduler:\n    def __init__(self, max_concurrent: int = 3):\n        self.max_concurrent = max_concurrent\n        self.task_queue = []\n        self.running_tasks = set()\n        self.completed_tasks = []\n        self.task_counter = 0\n    \n    def schedule_task(self, priority: int, delay: float, execution_time: int) -> int:\n        \"\"\"Schedule a new task with given priority, delay and execution time\"\"\"\n        # Your implementation here\n        return 0\n    \n    async def execute_task(self, task: Task) -> None:\n        \"\"\"Execute a single task\"\"\"\n        # Your implementation here\n        pass\n    \n    async def run_scheduler(self) -> List[str]:\n        \"\"\"Run the task scheduler until all tasks complete\"\"\"\n        # Your implementation here\n        return []\n    \n    def get_task_by_id(self, task_id: int) -> Optional[Task]:\n        \"\"\"Get task by ID\"\"\"\n        # Your implementation here\n        return None\n    \n    def cancel_task(self, task_id: int) -> bool:\n        \"\"\"Cancel a pending task\"\"\"\n        # Your implementation here\n        return False\n\ndef solve():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    \n    scheduler = AsyncTaskScheduler(max_concurrent=3)\n    results = []\n    \n    async def process_commands():\n        for line in lines:\n            parts = line.strip().split()\n            if not parts:\n                continue\n                \n            command = parts[0]\n            \n            if command == \"schedule\":\n                priority = int(parts[1])\n                delay = float(parts[2])\n                execution_time = int(parts[3])\n                task_id = scheduler.schedule_task(priority, delay, execution_time)\n                \n            elif command == \"run\":\n                task_results = await scheduler.run_scheduler()\n                results.extend(task_results)\n        \n        return results\n    \n    loop_results = asyncio.run(process_commands())\n    for result in loop_results:\n        print(result)\n\nif __name__ == '__main__':\n    solve()",
      "solutionCode": "import asyncio\nimport heapq\nimport time\nfrom typing import List, Optional, Callable, Any\nfrom dataclasses import dataclass\nfrom enum import Enum\n\nclass TaskStatus(Enum):\n    PENDING = \"pending\"\n    RUNNING = \"running\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n\n@dataclass\nclass Task:\n    id: int\n    priority: int\n    delay: float\n    execution_time: int  # milliseconds\n    status: TaskStatus = TaskStatus.PENDING\n    result: Any = None\n    \n    def __lt__(self, other):\n        # Higher priority number = higher priority (reverse order for min-heap)\n        return self.priority > other.priority\n\nclass AsyncTaskScheduler:\n    def __init__(self, max_concurrent: int = 3):\n        self.max_concurrent = max_concurrent\n        self.task_queue = []\n        self.running_tasks = set()\n        self.completed_tasks = []\n        self.task_counter = 0\n    \n    def schedule_task(self, priority: int, delay: float, execution_time: int) -> int:\n        \"\"\"Schedule a new task with given priority, delay and execution time\"\"\"\n        self.task_counter += 1\n        task = Task(\n            id=self.task_counter,\n            priority=priority,\n            delay=delay,\n            execution_time=execution_time\n        )\n        heapq.heappush(self.task_queue, task)\n        return self.task_counter\n    \n    async def execute_task(self, task: Task) -> None:\n        \"\"\"Execute a single task\"\"\"\n        try:\n            task.status = TaskStatus.RUNNING\n            \n            # Apply delay if specified\n            if task.delay > 0:\n                await asyncio.sleep(task.delay)\n            \n            # Simulate task execution\n            start_time = time.time()\n            await asyncio.sleep(task.execution_time / 1000.0)  # Convert ms to seconds\n            end_time = time.time()\n            \n            task.status = TaskStatus.COMPLETED\n            task.result = f\"Task {task.id} completed in {task.execution_time}ms\"\n            \n        except asyncio.CancelledError:\n            task.status = TaskStatus.CANCELLED\n            task.result = f\"Task {task.id} was cancelled\"\n            raise\n        except Exception as e:\n            task.status = TaskStatus.FAILED\n            task.result = f\"Task {task.id} failed: {str(e)}\"\n        finally:\n            self.running_tasks.discard(task)\n            self.completed_tasks.append(task)\n    \n    async def run_scheduler(self) -> List[str]:\n        \"\"\"Run the task scheduler until all tasks complete\"\"\"\n        results = []\n        \n        while self.task_queue or self.running_tasks:\n            # Start new tasks if we have capacity and pending tasks\n            while (len(self.running_tasks) < self.max_concurrent and \n                   self.task_queue):\n                task = heapq.heappop(self.task_queue)\n                \n                # Create and start the task\n                async_task = asyncio.create_task(self.execute_task(task))\n                self.running_tasks.add(task)\n            \n            # Wait for at least one task to complete\n            if self.running_tasks:\n                # Wait for any running task to complete\n                running_async_tasks = []\n                for task in list(self.running_tasks):\n                    if task.status == TaskStatus.RUNNING:\n                        running_async_tasks.append(\n                            asyncio.create_task(self.execute_task(task))\n                        )\n                \n                if running_async_tasks:\n                    done, pending = await asyncio.wait(\n                        running_async_tasks, \n                        return_when=asyncio.FIRST_COMPLETED\n                    )\n                    \n                    # Cancel remaining tasks to avoid orphaned tasks\n                    for task in pending:\n                        task.cancel()\n            \n            # Small delay to prevent busy waiting\n            await asyncio.sleep(0.01)\n        \n        # Sort completed tasks by completion order (priority-based)\n        self.completed_tasks.sort(key=lambda t: (-t.priority, t.id))\n        \n        for task in self.completed_tasks:\n            if task.result:\n                results.append(task.result)\n        \n        return results\n    \n    def get_task_by_id(self, task_id: int) -> Optional[Task]:\n        \"\"\"Get task by ID\"\"\"\n        # Search in queue\n        for task in self.task_queue:\n            if task.id == task_id:\n                return task\n        \n        # Search in running tasks\n        for task in self.running_tasks:\n            if task.id == task_id:\n                return task\n        \n        # Search in completed tasks\n        for task in self.completed_tasks:\n            if task.id == task_id:\n                return task\n        \n        return None\n    \n    def cancel_task(self, task_id: int) -> bool:\n        \"\"\"Cancel a pending task\"\"\"\n        # Remove from queue if pending\n        for i, task in enumerate(self.task_queue):\n            if task.id == task_id and task.status == TaskStatus.PENDING:\n                task.status = TaskStatus.CANCELLED\n                del self.task_queue[i]\n                heapq.heapify(self.task_queue)  # Restore heap property\n                return True\n        \n        return False\n\ndef solve():\n    import sys\n    lines = sys.stdin.read().strip().split('\\n')\n    \n    scheduler = AsyncTaskScheduler(max_concurrent=3)\n    results = []\n    \n    async def process_commands():\n        for line in lines:\n            parts = line.strip().split()\n            if not parts:\n                continue\n                \n            command = parts[0]\n            \n            if command == \"schedule\":\n                priority = int(parts[1])\n                delay = float(parts[2])\n                execution_time = int(parts[3])\n                task_id = scheduler.schedule_task(priority, delay, execution_time)\n                \n            elif command == \"run\":\n                task_results = await scheduler.run_scheduler()\n                results.extend(task_results)\n        \n        return results\n    \n    loop_results = asyncio.run(process_commands())\n    for result in loop_results:\n        print(result)\n\nif __name__ == '__main__':\n    solve()",
      "hints": [
        "Use heapq for priority queue implementation",
        "Track running tasks with asyncio.create_task()",
        "Handle task cancellation with asyncio.CancelledError",
        "Use asyncio.wait() with FIRST_COMPLETED for task management"
      ],
      "judge0Id": 92,
      "compilerType": "judge0"
    }
  },
  "testCases": [
    {
      "id": "test-basic-scheduling",
      "input": "schedule 1 0 100\\nrun",
      "output": "Task 1 completed in 100ms",
      "points": 5,
      "isHidden": false,
      "timeout": 15000
    },
    {
      "id": "test-priority-ordering",
      "input": "schedule 1 0 100\\nschedule 2 0 200\\nschedule 3 0 150\\nrun",
      "output": "Task 2 completed in 200ms\\nTask 3 completed in 150ms\\nTask 1 completed in 100ms",
      "points": 3,
      "isHidden": false,
      "timeout": 10000
    },
    {
      "id": "test-delayed-execution",
      "input": "schedule 1 0.1 100\\nschedule 2 0 200\\nrun",
      "output": "Task 2 completed in 200ms\\nTask 1 completed in 100ms",
      "points": 2,
      "isHidden": true,
      "timeout": 20000
    }
  ],
  "editorial": {
    "approach": "Async task scheduler uses priority queues, asyncio task management, and concurrent execution limits to efficiently schedule and execute tasks based on priority.",
    "complexity": {
      "time": "O(n log n) for task scheduling and O(n/c) for execution where n is tasks and c is concurrency limit",
      "space": "O(n) for storing tasks and results"
    },
    "keyPoints": [
      "Priority queue implementation with heapq for task ordering",
      "Asyncio.create_task() for concurrent task execution",
      "Task state management and status tracking",
      "Graceful handling of task delays and cancellation"
    ]
  }
}