{
  "id": "two-sum-array",
  "metadata": {
    "title": "Two Sum Problem",
    "description": "Given an array of integers and a target sum, find two numbers in the array that add up to the target.\n\n## Learning Objectives\n- Array manipulation and traversal\n- Hash table/map usage for optimization\n- Problem-solving with multiple approaches\n\n## Approach\nYou can solve this using:\n1. **Brute Force**: Check every pair (O(n²))\n2. **Hash Map**: Single pass with complement lookup (O(n))",
    "difficulty": "medium",
    "points": 2,
    "timeLimit": 15,
    "tags": ["arrays", "hash-map", "two-pointers", "algorithms"],
    "author": "Z-Challenge Team",
    "createdAt": "2025-10-02T20:00:00Z",
    "version": "1.0",
    "supportedLanguages": ["z--", "cpp", "python", "java"]
  },
  "problem": {
    "statement": "Given an array of integers `nums` and an integer `target`, return the indices of two numbers such that they add up to `target`. You may assume that each input would have exactly one solution, and you may not use the same element twice.",
    "inputFormat": "First line: integer n (array size)\nSecond line: n space-separated integers (array elements)\nThird line: integer target",
    "outputFormat": "Two space-separated integers representing the indices (0-based) of the two numbers that sum to target",
    "constraints": "2 ≤ n ≤ 10^4\n-10^9 ≤ nums[i] ≤ 10^9\n-10^9 ≤ target ≤ 10^9\nOnly one valid answer exists",
    "examples": [
      {
        "input": "4\n2 7 11 15\n9",
        "output": "0 1",
        "explanation": "nums[0] + nums[1] = 2 + 7 = 9, so we return [0, 1]"
      },
      {
        "input": "3\n3 2 4\n6",
        "output": "1 2", 
        "explanation": "nums[1] + nums[2] = 2 + 4 = 6, so we return [1, 2]"
      }
    ]
  },
  "languages": {
    "z--": {
      "starterCode": "start\n  // Read array size\n  let n = 0\n  \n  // Read array elements\n  // Your code here\n  \n  // Read target\n  let target = 0\n  \n  // Find two indices that sum to target\n  // Print the indices\n  \nend",
      "solutionCode": "start\n  let n = 0\n  // Read n\n  \n  let arr[1000]\n  let i = 0\n  while i < n\n    // Read arr[i]\n    i = i + 1\n  end\n  \n  let target = 0\n  // Read target\n  \n  // Brute force approach\n  i = 0\n  while i < n\n    let j = i + 1\n    while j < n\n      if arr[i] + arr[j] == target\n        print(i)\n        print(\" \")\n        print(j)\n        return\n      end\n      j = j + 1\n    end\n    i = i + 1\n  end\nend",
      "hints": [
        "Try a nested loop approach first (brute force)",
        "For each element, check if target-element exists in remaining array",
        "Consider using arrays to store values and indices"
      ],
      "judge0Id": null,
      "compilerType": "z-studio"
    },
    "cpp": {
      "starterCode": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> nums(n);\n    for(int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n    \n    int target;\n    cin >> target;\n    \n    // Your code here\n    // Find indices and print them\n    \n    return 0;\n}",
      "solutionCode": "#include <iostream>\n#include <vector>\n#include <unordered_map>\nusing namespace std;\n\nint main() {\n    int n;\n    cin >> n;\n    \n    vector<int> nums(n);\n    for(int i = 0; i < n; i++) {\n        cin >> nums[i];\n    }\n    \n    int target;\n    cin >> target;\n    \n    unordered_map<int, int> map;\n    \n    for(int i = 0; i < n; i++) {\n        int complement = target - nums[i];\n        if(map.find(complement) != map.end()) {\n            cout << map[complement] << \" \" << i << endl;\n            return 0;\n        }\n        map[nums[i]] = i;\n    }\n    \n    return 0;\n}",
      "hints": [
        "Use unordered_map to store value->index mapping",
        "For each element, check if (target - element) exists in map",
        "Store current element in map after checking"
      ],
      "judge0Id": 54,
      "compilerType": "judge0"
    },
    "python": {
      "starterCode": "n = int(input())\nnums = list(map(int, input().split()))\ntarget = int(input())\n\n# Your code here\n# Find indices and print them",
      "solutionCode": "n = int(input())\nnums = list(map(int, input().split()))\ntarget = int(input())\n\nnum_map = {}\nfor i, num in enumerate(nums):\n    complement = target - num\n    if complement in num_map:\n        print(num_map[complement], i)\n        break\n    num_map[num] = i",
      "hints": [
        "Use a dictionary to store number->index mapping",
        "Use enumerate() to get both index and value",
        "Check if complement exists before adding current number"
      ],
      "judge0Id": 71,
      "compilerType": "judge0"
    },
    "java": {
      "starterCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        int[] nums = new int[n];\n        for(int i = 0; i < n; i++) {\n            nums[i] = sc.nextInt();\n        }\n        \n        int target = sc.nextInt();\n        \n        // Your code here\n        // Find indices and print them\n    }\n}",
      "solutionCode": "import java.util.*;\n\npublic class Main {\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n        int n = sc.nextInt();\n        \n        int[] nums = new int[n];\n        for(int i = 0; i < n; i++) {\n            nums[i] = sc.nextInt();\n        }\n        \n        int target = sc.nextInt();\n        \n        HashMap<Integer, Integer> map = new HashMap<>();\n        \n        for(int i = 0; i < n; i++) {\n            int complement = target - nums[i];\n            if(map.containsKey(complement)) {\n                System.out.println(map.get(complement) + \" \" + i);\n                return;\n            }\n            map.put(nums[i], i);\n        }\n    }\n}",
      "hints": [
        "Use HashMap<Integer, Integer> for value->index mapping",
        "Use containsKey() to check if complement exists",
        "Remember to put current number in map after checking"
      ],
      "judge0Id": 62,
      "compilerType": "judge0"
    }
  },
  "testCases": [
    {
      "id": "test-basic-1",
      "input": "4\n2 7 11 15\n9",
      "output": "0 1",
      "points": 25,
      "isHidden": false,
      "timeout": 2000
    },
    {
      "id": "test-basic-2", 
      "input": "3\n3 2 4\n6",
      "output": "1 2",
      "points": 25,
      "isHidden": false,
      "timeout": 2000
    },
    {
      "id": "test-edge-1",
      "input": "2\n3 3\n6",
      "output": "0 1",
      "points": 25,
      "isHidden": true,
      "timeout": 2000
    },
    {
      "id": "test-negative",
      "input": "4\n-1 -2 -3 -4\n-6",
      "output": "1 3",
      "points": 25,
      "isHidden": true,
      "timeout": 2000
    }
  ],
  "editorial": {
    "approach": "The optimal solution uses a hash map to achieve O(n) time complexity. As we iterate through the array, for each element we check if its complement (target - current_element) exists in our hash map. If it does, we found our answer. If not, we add the current element and its index to the hash map.",
    "complexity": {
      "time": "O(n)",
      "space": "O(n)"
    },
    "keywords": ["hash-map", "array-traversal", "complement-search", "optimization"]
  }
}