{
  "id": "py-coroutine-scheduler",
  "metadata": {
    "title": "Python Coroutine Scheduler with Async Patterns",
    "description": "Build an advanced coroutine scheduler implementing cooperative multitasking and async patterns.\n\n## Learning Objectives\n- Understanding Python coroutines and generators\n- Implementing cooperative scheduling\n- Advanced async/await patterns\n- Event loop fundamentals",
    "difficulty": "hard",
    "points": 3,
    "timeLimit": 30,
    "tags": ["python", "coroutines", "async", "scheduler", "generators"],
    "author": "Z-Challenge Team",
    "createdAt": "2025-10-05T12:10:00Z",
    "version": "1.0",
    "supportedLanguages": ["python"]
  },
  "problem": {
    "statement": "Create a coroutine scheduler that manages cooperative multitasking with support for delays, timeouts, and task dependencies.",
    "inputFormat": "Task definitions and scheduler operations",
    "outputFormat": "Task execution results and scheduling information",
    "constraints": "- Use generators/coroutines for cooperative scheduling\n- Support task delays and timeouts\n- Implement task priorities and dependencies\n- Handle task completion and error propagation",
    "examples": [
      {
        "input": "schedule_task('A', delay=1)\\nschedule_task('B', delay=2)\\nrun_scheduler()",
        "output": "Task A started\\nTask A completed\\nTask B started\\nTask B completed",
        "explanation": "Tasks scheduled with delays and executed cooperatively"
      }
    ]
  },
  "languages": {
    "python": {
      "starterCode": "import heapq\nimport time\nfrom typing import Any, Callable, Generator, Optional, Dict, List\nfrom collections import deque\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass Task:\n    \"\"\"Represents a schedulable task\"\"\"\n    name: str\n    coroutine: Generator\n    priority: int = 0\n    created_at: float = field(default_factory=time.time)\n    dependencies: List[str] = field(default_factory=list)\n    completed: bool = False\n    result: Any = None\n    error: Optional[Exception] = None\n    \n    def __lt__(self, other):\n        return self.priority < other.priority\n\nclass CoroutineScheduler:\n    \"\"\"Advanced coroutine scheduler with cooperative multitasking\"\"\"\n    \n    def __init__(self):\n        self.tasks: Dict[str, Task] = {}\n        self.ready_queue = []\n        self.waiting_tasks: Dict[str, float] = {}  # task_name -> wake_time\n        self.current_time = 0.0\n        self.running = False\n        \n    def schedule_task(self, name: str, coroutine_func: Callable, \n                     priority: int = 0, dependencies: List[str] = None, *args, **kwargs):\n        \"\"\"Schedule a new task\"\"\"\n        # Your implementation here\n        pass\n        \n    def delay(self, seconds: float):\n        \"\"\"Coroutine that yields control for specified seconds\"\"\"\n        # Your implementation here\n        pass\n        \n    def wait_for_task(self, task_name: str):\n        \"\"\"Coroutine that waits for another task to complete\"\"\"\n        # Your implementation here\n        pass\n        \n    def run_scheduler(self, max_time: float = 10.0):\n        \"\"\"Run the scheduler until all tasks complete or timeout\"\"\"\n        # Your implementation here\n        pass\n        \n    def _advance_time(self):\n        \"\"\"Advance scheduler time and wake up delayed tasks\"\"\"\n        # Your implementation here\n        pass\n        \n    def _check_dependencies(self, task: Task) -> bool:\n        \"\"\"Check if task dependencies are satisfied\"\"\"\n        # Your implementation here\n        return True\n\n# Example coroutine functions\ndef example_task(scheduler, name: str, delay_time: float):\n    \"\"\"Example task that prints messages and delays\"\"\"\n    print(f\"Task {name} started\")\n    yield from scheduler.delay(delay_time)\n    print(f\"Task {name} completed\")\n    return f\"Result from {name}\"\n\ndef dependent_task(scheduler, name: str, dependency: str):\n    \"\"\"Example task that depends on another task\"\"\"\n    print(f\"Task {name} waiting for {dependency}\")\n    result = yield from scheduler.wait_for_task(dependency)\n    print(f\"Task {name} got result: {result}\")\n    return f\"Processed by {name}\"\n\ndef producer_task(scheduler, name: str, count: int):\n    \"\"\"Producer task that generates values\"\"\"\n    for i in range(count):\n        print(f\"Producer {name} generating item {i}\")\n        yield from scheduler.delay(0.5)\n    return f\"Producer {name} finished\"\n\n# Test the scheduler\nif __name__ == \"__main__\":\n    scheduler = CoroutineScheduler()\n    \n    # Schedule some tasks\n    scheduler.schedule_task(\"A\", example_task, args=(scheduler, \"A\", 1.0))\n    scheduler.schedule_task(\"B\", example_task, priority=1, args=(scheduler, \"B\", 2.0))\n    scheduler.schedule_task(\"C\", dependent_task, dependencies=[\"A\"], args=(scheduler, \"C\", \"A\"))\n    scheduler.schedule_task(\"Producer\", producer_task, args=(scheduler, \"Producer\", 3))\n    \n    print(\"Starting scheduler...\")\n    scheduler.run_scheduler()\n    print(\"Scheduler finished\")\n    \n    # Print results\n    for name, task in scheduler.tasks.items():\n        if task.completed:\n            print(f\"Task {name} result: {task.result}\")\n        elif task.error:\n            print(f\"Task {name} error: {task.error}\")",
      "solutionCode": "import heapq\nimport time\nfrom typing import Any, Callable, Generator, Optional, Dict, List\nfrom collections import deque\nfrom dataclasses import dataclass, field\n\n@dataclass\nclass Task:\n    \"\"\"Represents a schedulable task\"\"\"\n    name: str\n    coroutine: Generator\n    priority: int = 0\n    created_at: float = field(default_factory=time.time)\n    dependencies: List[str] = field(default_factory=list)\n    completed: bool = False\n    result: Any = None\n    error: Optional[Exception] = None\n    \n    def __lt__(self, other):\n        return self.priority < other.priority\n\nclass DelayRequest:\n    \"\"\"Request to delay execution\"\"\"\n    def __init__(self, seconds: float):\n        self.seconds = seconds\n\nclass WaitRequest:\n    \"\"\"Request to wait for another task\"\"\"\n    def __init__(self, task_name: str):\n        self.task_name = task_name\n\nclass CoroutineScheduler:\n    \"\"\"Advanced coroutine scheduler with cooperative multitasking\"\"\"\n    \n    def __init__(self):\n        self.tasks: Dict[str, Task] = {}\n        self.ready_queue = []\n        self.waiting_tasks: Dict[str, float] = {}  # task_name -> wake_time\n        self.current_time = 0.0\n        self.running = False\n        self.time_step = 0.1  # Time increment for simulation\n        \n    def schedule_task(self, name: str, coroutine_func: Callable, \n                     priority: int = 0, dependencies: List[str] = None, *args, **kwargs):\n        \"\"\"Schedule a new task\"\"\"\n        if name in self.tasks:\n            raise ValueError(f\"Task {name} already exists\")\n            \n        coroutine = coroutine_func(*args, **kwargs)\n        task = Task(\n            name=name,\n            coroutine=coroutine,\n            priority=priority,\n            dependencies=dependencies or []\n        )\n        \n        self.tasks[name] = task\n        \n        # Add to ready queue if dependencies are satisfied\n        if self._check_dependencies(task):\n            heapq.heappush(self.ready_queue, (task.priority, task.created_at, task))\n        \n    def delay(self, seconds: float):\n        \"\"\"Coroutine that yields control for specified seconds\"\"\"\n        yield DelayRequest(seconds)\n        \n    def wait_for_task(self, task_name: str):\n        \"\"\"Coroutine that waits for another task to complete\"\"\"\n        while task_name not in self.tasks or not self.tasks[task_name].completed:\n            yield WaitRequest(task_name)\n        \n        task = self.tasks[task_name]\n        if task.error:\n            raise task.error\n        return task.result\n        \n    def run_scheduler(self, max_time: float = 10.0):\n        \"\"\"Run the scheduler until all tasks complete or timeout\"\"\"\n        self.running = True\n        start_time = time.time()\n        \n        while self.running and (time.time() - start_time) < max_time:\n            # Advance simulation time\n            self._advance_time()\n            \n            # Process ready tasks\n            tasks_processed = 0\n            while self.ready_queue and tasks_processed < 10:  # Limit per cycle\n                _, _, task = heapq.heappop(self.ready_queue)\n                \n                if task.completed:\n                    continue\n                    \n                try:\n                    # Execute one step of the coroutine\n                    request = next(task.coroutine)\n                    \n                    if isinstance(request, DelayRequest):\n                        # Schedule task to wake up later\n                        wake_time = self.current_time + request.seconds\n                        self.waiting_tasks[task.name] = wake_time\n                        \n                    elif isinstance(request, WaitRequest):\n                        # Check if dependency is ready\n                        dep_task = self.tasks.get(request.task_name)\n                        if dep_task and dep_task.completed:\n                            # Dependency satisfied, re-queue immediately\n                            heapq.heappush(self.ready_queue, \n                                         (task.priority, task.created_at, task))\n                        else:\n                            # Still waiting, re-queue with delay\n                            wake_time = self.current_time + 0.1\n                            self.waiting_tasks[task.name] = wake_time\n                    else:\n                        # Unknown request, re-queue task\n                        heapq.heappush(self.ready_queue, \n                                     (task.priority, task.created_at, task))\n                        \n                except StopIteration as e:\n                    # Task completed\n                    task.completed = True\n                    task.result = e.value\n                    \n                    # Check if any waiting tasks can now run\n                    self._check_waiting_dependencies()\n                    \n                except Exception as e:\n                    # Task failed\n                    task.completed = True\n                    task.error = e\n                    print(f\"Task {task.name} failed: {e}\")\n                    \n                tasks_processed += 1\n            \n            # Check if all tasks are complete\n            if all(task.completed for task in self.tasks.values()):\n                self.running = False\n                break\n                \n            # Small delay to prevent busy waiting\n            time.sleep(0.01)\n        \n        if self.running:\n            print(\"Scheduler timeout reached\")\n        \n    def _advance_time(self):\n        \"\"\"Advance scheduler time and wake up delayed tasks\"\"\"\n        self.current_time += self.time_step\n        \n        # Check for tasks to wake up\n        ready_tasks = []\n        for task_name, wake_time in list(self.waiting_tasks.items()):\n            if self.current_time >= wake_time:\n                task = self.tasks[task_name]\n                if not task.completed and self._check_dependencies(task):\n                    heapq.heappush(self.ready_queue, \n                                 (task.priority, task.created_at, task))\n                del self.waiting_tasks[task_name]\n                \n    def _check_dependencies(self, task: Task) -> bool:\n        \"\"\"Check if task dependencies are satisfied\"\"\"\n        for dep_name in task.dependencies:\n            if dep_name not in self.tasks or not self.tasks[dep_name].completed:\n                return False\n        return True\n        \n    def _check_waiting_dependencies(self):\n        \"\"\"Check if any tasks are waiting for dependencies that are now ready\"\"\"\n        for task in self.tasks.values():\n            if (not task.completed and \n                task.name not in self.waiting_tasks and \n                self._check_dependencies(task)):\n                # Add any dependency-satisfied tasks back to ready queue\n                found_in_queue = any(t.name == task.name for _, _, t in self.ready_queue)\n                if not found_in_queue:\n                    heapq.heappush(self.ready_queue, \n                                 (task.priority, task.created_at, task))\n\n# Example coroutine functions\ndef example_task(scheduler, name: str, delay_time: float):\n    \"\"\"Example task that prints messages and delays\"\"\"\n    print(f\"Task {name} started\")\n    yield from scheduler.delay(delay_time)\n    print(f\"Task {name} completed\")\n    return f\"Result from {name}\"\n\ndef dependent_task(scheduler, name: str, dependency: str):\n    \"\"\"Example task that depends on another task\"\"\"\n    print(f\"Task {name} waiting for {dependency}\")\n    result = yield from scheduler.wait_for_task(dependency)\n    print(f\"Task {name} got result: {result}\")\n    return f\"Processed by {name}\"\n\ndef producer_task(scheduler, name: str, count: int):\n    \"\"\"Producer task that generates values\"\"\"\n    for i in range(count):\n        print(f\"Producer {name} generating item {i}\")\n        yield from scheduler.delay(0.5)\n    return f\"Producer {name} finished\"\n\n# Test the scheduler\nif __name__ == \"__main__\":\n    scheduler = CoroutineScheduler()\n    \n    # Schedule some tasks\n    scheduler.schedule_task(\"A\", example_task, args=(scheduler, \"A\", 1.0))\n    scheduler.schedule_task(\"B\", example_task, priority=1, args=(scheduler, \"B\", 2.0))\n    scheduler.schedule_task(\"C\", dependent_task, dependencies=[\"A\"], args=(scheduler, \"C\", \"A\"))\n    scheduler.schedule_task(\"Producer\", producer_task, args=(scheduler, \"Producer\", 3))\n    \n    print(\"Starting scheduler...\")\n    scheduler.run_scheduler()\n    print(\"Scheduler finished\")\n    \n    # Print results\n    for name, task in scheduler.tasks.items():\n        if task.completed:\n            print(f\"Task {name} result: {task.result}\")\n        elif task.error:\n            print(f\"Task {name} error: {task.error}\")",
      "hints": [
        "Use yield to create cooperative multitasking points",
        "Implement request objects for different scheduler operations",
        "Use heapq for priority-based task scheduling",
        "Handle StopIteration to capture coroutine return values"
      ],
      "judge0Id": 71,
      "compilerType": "judge0"
    }
  },
  "testCases": [
    {
      "id": "test-scheduler-basic",
      "input": "",
      "output": "Starting scheduler...\\nTask A started\\nTask B started\\nTask Producer generating item 0\\nTask C waiting for A\\nTask A completed\\nTask C got result: Result from A\\nProducer Producer generating item 1\\nTask B completed\\nProducer Producer generating item 2\\nScheduler finished\\nTask A result: Result from A\\nTask B result: Result from B\\nTask C result: Processed by C\\nTask Producer result: Producer Producer finished",
      "points": 7,
      "isHidden": false,
      "timeout": 10000
    },
    {
      "id": "test-scheduler-dependencies",
      "input": "",
      "output": "Starting scheduler...\\nTask A started\\nTask B started\\nTask C waiting for A",
      "points": 3,
      "isHidden": true,
      "timeout": 5000
    }
  ],
  "editorial": {
    "approach": "Coroutine schedulers enable cooperative multitasking through generator-based coroutines, providing fine-grained control over task execution and resource sharing without thread overhead.",
    "complexity": {
      "time": "O(n log n) for task scheduling with priority queue, O(k) per task execution step",
      "space": "O(n) for storing tasks and scheduling state"
    },
    "keyPoints": [
      "Generator-based coroutines for cooperative multitasking",
      "Priority queue for task scheduling with heapq",
      "Request objects for scheduler communication",
      "Dependency resolution and task synchronization"
    ]
  }
}