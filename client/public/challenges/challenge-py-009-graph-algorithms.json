{
  "id": "py-graph-algorithms",
  "metadata": {
    "title": "Python Advanced Graph Algorithms Implementation",
    "description": "Implement sophisticated graph algorithms including shortest paths, maximum flow, and graph analysis.\n\n## Learning Objectives\n- Advanced graph data structures\n- Dijkstra's and Floyd-Warshall algorithms\n- Maximum flow algorithms\n- Graph traversal optimizations",
    "difficulty": "hard",
    "points": 3,
    "timeLimit": 30,
    "tags": ["python", "graphs", "algorithms", "dijkstra", "max-flow"],
    "author": "Z-Challenge Team",
    "createdAt": "2025-10-05T12:15:00Z",
    "version": "1.0",
    "supportedLanguages": ["python"]
  },
  "problem": {
    "statement": "Build a comprehensive graph library supporting weighted/unweighted graphs with advanced algorithms for pathfinding, flow analysis, and connectivity.",
    "inputFormat": "Graph operations: add_edge, shortest_path, max_flow, detect_cycle, etc.",
    "outputFormat": "Algorithm results and graph analysis",
    "constraints": "- Support both directed and undirected graphs\n- Implement multiple shortest path algorithms\n- Handle negative edge weights appropriately\n- Provide comprehensive graph analysis",
    "examples": [
      {
        "input": "add_edge A B 5\\nadd_edge B C 3\\nshortest_path A C",
        "output": "Path: A -> B -> C, Distance: 8",
        "explanation": "Find shortest path from A to C through B"
      }
    ]
  },
  "languages": {
    "python": {
      "starterCode": "import heapq\nfrom collections import defaultdict, deque\nfrom typing import Dict, List, Tuple, Set, Optional, Union\nfrom dataclasses import dataclass\nimport math\n\n@dataclass\nclass Edge:\n    \"\"\"Represents a graph edge\"\"\"\n    to: str\n    weight: float = 1.0\n    capacity: float = float('inf')\n    flow: float = 0.0\n    \n    def available_capacity(self) -> float:\n        return self.capacity - self.flow\n\nclass Graph:\n    \"\"\"Advanced graph implementation with multiple algorithms\"\"\"\n    \n    def __init__(self, directed: bool = True):\n        self.directed = directed\n        self.vertices: Set[str] = set()\n        self.edges: Dict[str, List[Edge]] = defaultdict(list)\n        self.edge_count = 0\n        \n    def add_vertex(self, vertex: str):\n        \"\"\"Add a vertex to the graph\"\"\"\n        # Your implementation here\n        pass\n        \n    def add_edge(self, from_vertex: str, to_vertex: str, weight: float = 1.0, capacity: float = float('inf')):\n        \"\"\"Add an edge to the graph\"\"\"\n        # Your implementation here\n        pass\n        \n    def dijkstra(self, start: str, end: str = None) -> Dict[str, Tuple[float, List[str]]]:\n        \"\"\"Dijkstra's shortest path algorithm\"\"\"\n        # Your implementation here\n        return {}\n        \n    def bellman_ford(self, start: str) -> Tuple[Dict[str, float], Dict[str, str], bool]:\n        \"\"\"Bellman-Ford algorithm (handles negative weights)\"\"\"\n        # Your implementation here\n        return {}, {}, True\n        \n    def floyd_warshall(self) -> Dict[Tuple[str, str], float]:\n        \"\"\"Floyd-Warshall all-pairs shortest path\"\"\"\n        # Your implementation here\n        return {}\n        \n    def max_flow_ford_fulkerson(self, source: str, sink: str) -> float:\n        \"\"\"Maximum flow using Ford-Fulkerson algorithm\"\"\"\n        # Your implementation here\n        return 0.0\n        \n    def detect_cycle(self) -> bool:\n        \"\"\"Detect if graph contains a cycle\"\"\"\n        # Your implementation here\n        return False\n        \n    def topological_sort(self) -> List[str]:\n        \"\"\"Topological sorting for DAG\"\"\"\n        # Your implementation here\n        return []\n        \n    def strongly_connected_components(self) -> List[List[str]]:\n        \"\"\"Find strongly connected components (Kosaraju's algorithm)\"\"\"\n        # Your implementation here\n        return []\n        \n    def minimum_spanning_tree(self) -> List[Tuple[str, str, float]]:\n        \"\"\"Minimum spanning tree using Kruskal's algorithm\"\"\"\n        # Your implementation here\n        return []\n        \n    def is_bipartite(self) -> Tuple[bool, Dict[str, int]]:\n        \"\"\"Check if graph is bipartite\"\"\"\n        # Your implementation here\n        return False, {}\n\n# Test the graph implementation\nif __name__ == \"__main__\":\n    # Test directed graph\n    g = Graph(directed=True)\n    \n    # Add edges\n    g.add_edge(\"A\", \"B\", 5)\n    g.add_edge(\"A\", \"C\", 3)\n    g.add_edge(\"B\", \"C\", 2)\n    g.add_edge(\"B\", \"D\", 4)\n    g.add_edge(\"C\", \"D\", 1)\n    \n    print(\"Graph created with vertices:\", g.vertices)\n    print(\"Edge count:\", g.edge_count)\n    \n    # Test Dijkstra's algorithm\n    distances = g.dijkstra(\"A\")\n    print(\"\\nDijkstra from A:\")\n    for vertex, (dist, path) in distances.items():\n        print(f\"  {vertex}: distance {dist}, path {' -> '.join(path)}\")\n    \n    # Test cycle detection\n    has_cycle = g.detect_cycle()\n    print(f\"\\nHas cycle: {has_cycle}\")\n    \n    # Test topological sort\n    if not has_cycle:\n        topo_order = g.topological_sort()\n        print(f\"Topological order: {' -> '.join(topo_order)}\")\n    \n    # Test undirected graph for MST\n    ug = Graph(directed=False)\n    ug.add_edge(\"A\", \"B\", 4)\n    ug.add_edge(\"A\", \"C\", 2)\n    ug.add_edge(\"B\", \"C\", 1)\n    ug.add_edge(\"B\", \"D\", 5)\n    ug.add_edge(\"C\", \"D\", 8)\n    ug.add_edge(\"C\", \"E\", 10)\n    ug.add_edge(\"D\", \"E\", 2)\n    \n    mst = ug.minimum_spanning_tree()\n    print(f\"\\nMinimum Spanning Tree:\")\n    total_weight = 0\n    for u, v, w in mst:\n        print(f\"  {u} - {v}: {w}\")\n        total_weight += w\n    print(f\"Total MST weight: {total_weight}\")\n    \n    # Test bipartite check\n    is_bip, coloring = ug.is_bipartite()\n    print(f\"\\nIs bipartite: {is_bip}\")\n    if is_bip:\n        print(\"Coloring:\", coloring)",
      "solutionCode": "import heapq\nfrom collections import defaultdict, deque\nfrom typing import Dict, List, Tuple, Set, Optional, Union\nfrom dataclasses import dataclass\nimport math\n\n@dataclass\nclass Edge:\n    \"\"\"Represents a graph edge\"\"\"\n    to: str\n    weight: float = 1.0\n    capacity: float = float('inf')\n    flow: float = 0.0\n    \n    def available_capacity(self) -> float:\n        return self.capacity - self.flow\n\nclass UnionFind:\n    \"\"\"Union-Find data structure for MST\"\"\"\n    def __init__(self, vertices):\n        self.parent = {v: v for v in vertices}\n        self.rank = {v: 0 for v in vertices}\n    \n    def find(self, x):\n        if self.parent[x] != x:\n            self.parent[x] = self.find(self.parent[x])\n        return self.parent[x]\n    \n    def union(self, x, y):\n        px, py = self.find(x), self.find(y)\n        if px == py:\n            return False\n        if self.rank[px] < self.rank[py]:\n            px, py = py, px\n        self.parent[py] = px\n        if self.rank[px] == self.rank[py]:\n            self.rank[px] += 1\n        return True\n\nclass Graph:\n    \"\"\"Advanced graph implementation with multiple algorithms\"\"\"\n    \n    def __init__(self, directed: bool = True):\n        self.directed = directed\n        self.vertices: Set[str] = set()\n        self.edges: Dict[str, List[Edge]] = defaultdict(list)\n        self.edge_count = 0\n        \n    def add_vertex(self, vertex: str):\n        \"\"\"Add a vertex to the graph\"\"\"\n        self.vertices.add(vertex)\n        \n    def add_edge(self, from_vertex: str, to_vertex: str, weight: float = 1.0, capacity: float = float('inf')):\n        \"\"\"Add an edge to the graph\"\"\"\n        self.add_vertex(from_vertex)\n        self.add_vertex(to_vertex)\n        \n        self.edges[from_vertex].append(Edge(to_vertex, weight, capacity))\n        self.edge_count += 1\n        \n        if not self.directed:\n            self.edges[to_vertex].append(Edge(from_vertex, weight, capacity))\n            self.edge_count += 1\n        \n    def dijkstra(self, start: str, end: str = None) -> Dict[str, Tuple[float, List[str]]]:\n        \"\"\"Dijkstra's shortest path algorithm\"\"\"\n        distances = {v: float('inf') for v in self.vertices}\n        distances[start] = 0\n        previous = {v: None for v in self.vertices}\n        \n        pq = [(0, start)]\n        visited = set()\n        \n        while pq:\n            current_dist, current = heapq.heappop(pq)\n            \n            if current in visited:\n                continue\n                \n            visited.add(current)\n            \n            if end and current == end:\n                break\n                \n            for edge in self.edges[current]:\n                if edge.to not in visited:\n                    new_dist = current_dist + edge.weight\n                    if new_dist < distances[edge.to]:\n                        distances[edge.to] = new_dist\n                        previous[edge.to] = current\n                        heapq.heappush(pq, (new_dist, edge.to))\n        \n        # Reconstruct paths\n        result = {}\n        for vertex in self.vertices:\n            if distances[vertex] != float('inf'):\n                path = []\n                current = vertex\n                while current is not None:\n                    path.append(current)\n                    current = previous[current]\n                path.reverse()\n                result[vertex] = (distances[vertex], path)\n        \n        return result\n        \n    def bellman_ford(self, start: str) -> Tuple[Dict[str, float], Dict[str, str], bool]:\n        \"\"\"Bellman-Ford algorithm (handles negative weights)\"\"\"\n        distances = {v: float('inf') for v in self.vertices}\n        distances[start] = 0\n        previous = {v: None for v in self.vertices}\n        \n        # Relax edges V-1 times\n        for _ in range(len(self.vertices) - 1):\n            for vertex in self.vertices:\n                if distances[vertex] != float('inf'):\n                    for edge in self.edges[vertex]:\n                        new_dist = distances[vertex] + edge.weight\n                        if new_dist < distances[edge.to]:\n                            distances[edge.to] = new_dist\n                            previous[edge.to] = vertex\n        \n        # Check for negative cycles\n        has_negative_cycle = False\n        for vertex in self.vertices:\n            if distances[vertex] != float('inf'):\n                for edge in self.edges[vertex]:\n                    if distances[vertex] + edge.weight < distances[edge.to]:\n                        has_negative_cycle = True\n                        break\n        \n        return distances, previous, not has_negative_cycle\n        \n    def floyd_warshall(self) -> Dict[Tuple[str, str], float]:\n        \"\"\"Floyd-Warshall all-pairs shortest path\"\"\"\n        vertices = list(self.vertices)\n        n = len(vertices)\n        dist = {}\n        \n        # Initialize distances\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    dist[(vertices[i], vertices[j])] = 0\n                else:\n                    dist[(vertices[i], vertices[j])] = float('inf')\n        \n        # Set edge weights\n        for vertex in self.vertices:\n            for edge in self.edges[vertex]:\n                dist[(vertex, edge.to)] = edge.weight\n        \n        # Floyd-Warshall algorithm\n        for k in range(n):\n            for i in range(n):\n                for j in range(n):\n                    if (dist[(vertices[i], vertices[k])] + \n                        dist[(vertices[k], vertices[j])] < \n                        dist[(vertices[i], vertices[j])]):\n                        dist[(vertices[i], vertices[j])] = (\n                            dist[(vertices[i], vertices[k])] + \n                            dist[(vertices[k], vertices[j])])\n        \n        return dist\n        \n    def _bfs_max_flow(self, source: str, sink: str, parent: Dict[str, str]) -> bool:\n        \"\"\"BFS to find augmenting path for max flow\"\"\"\n        visited = set([source])\n        queue = deque([source])\n        \n        while queue:\n            current = queue.popleft()\n            \n            for edge in self.edges[current]:\n                if edge.to not in visited and edge.available_capacity() > 0:\n                    visited.add(edge.to)\n                    parent[edge.to] = current\n                    if edge.to == sink:\n                        return True\n                    queue.append(edge.to)\n        \n        return False\n        \n    def max_flow_ford_fulkerson(self, source: str, sink: str) -> float:\n        \"\"\"Maximum flow using Ford-Fulkerson algorithm\"\"\"\n        # Reset all flows\n        for vertex in self.vertices:\n            for edge in self.edges[vertex]:\n                edge.flow = 0\n        \n        parent = {}\n        max_flow = 0\n        \n        while self._bfs_max_flow(source, sink, parent):\n            # Find minimum capacity along the path\n            path_flow = float('inf')\n            s = sink\n            \n            while s != source:\n                for edge in self.edges[parent[s]]:\n                    if edge.to == s:\n                        path_flow = min(path_flow, edge.available_capacity())\n                        break\n                s = parent[s]\n            \n            # Update flows along the path\n            v = sink\n            while v != source:\n                for edge in self.edges[parent[v]]:\n                    if edge.to == v:\n                        edge.flow += path_flow\n                        break\n                # Add reverse edge flow\n                found_reverse = False\n                for edge in self.edges[v]:\n                    if edge.to == parent[v]:\n                        edge.flow -= path_flow\n                        found_reverse = True\n                        break\n                if not found_reverse:\n                    # Create reverse edge if doesn't exist\n                    self.edges[v].append(Edge(parent[v], 0, 0, -path_flow))\n                v = parent[v]\n            \n            max_flow += path_flow\n            parent.clear()\n        \n        return max_flow\n        \n    def detect_cycle(self) -> bool:\n        \"\"\"Detect if graph contains a cycle\"\"\"\n        if not self.directed:\n            # Undirected graph - use DFS\n            visited = set()\n            \n            def dfs(vertex, parent):\n                visited.add(vertex)\n                for edge in self.edges[vertex]:\n                    if edge.to not in visited:\n                        if dfs(edge.to, vertex):\n                            return True\n                    elif edge.to != parent:\n                        return True\n                return False\n            \n            for vertex in self.vertices:\n                if vertex not in visited:\n                    if dfs(vertex, None):\n                        return True\n            return False\n        else:\n            # Directed graph - use DFS with colors\n            WHITE, GRAY, BLACK = 0, 1, 2\n            colors = {v: WHITE for v in self.vertices}\n            \n            def dfs(vertex):\n                colors[vertex] = GRAY\n                for edge in self.edges[vertex]:\n                    if colors[edge.to] == GRAY:\n                        return True\n                    if colors[edge.to] == WHITE and dfs(edge.to):\n                        return True\n                colors[vertex] = BLACK\n                return False\n            \n            for vertex in self.vertices:\n                if colors[vertex] == WHITE:\n                    if dfs(vertex):\n                        return True\n            return False\n        \n    def topological_sort(self) -> List[str]:\n        \"\"\"Topological sorting for DAG\"\"\"\n        if not self.directed or self.detect_cycle():\n            return []\n        \n        in_degree = {v: 0 for v in self.vertices}\n        for vertex in self.vertices:\n            for edge in self.edges[vertex]:\n                in_degree[edge.to] += 1\n        \n        queue = deque([v for v in self.vertices if in_degree[v] == 0])\n        result = []\n        \n        while queue:\n            vertex = queue.popleft()\n            result.append(vertex)\n            \n            for edge in self.edges[vertex]:\n                in_degree[edge.to] -= 1\n                if in_degree[edge.to] == 0:\n                    queue.append(edge.to)\n        \n        return result if len(result) == len(self.vertices) else []\n        \n    def strongly_connected_components(self) -> List[List[str]]:\n        \"\"\"Find strongly connected components (Kosaraju's algorithm)\"\"\"\n        if not self.directed:\n            return [[v] for v in self.vertices]\n        \n        # First DFS to get finish times\n        visited = set()\n        finish_stack = []\n        \n        def dfs1(vertex):\n            visited.add(vertex)\n            for edge in self.edges[vertex]:\n                if edge.to not in visited:\n                    dfs1(edge.to)\n            finish_stack.append(vertex)\n        \n        for vertex in self.vertices:\n            if vertex not in visited:\n                dfs1(vertex)\n        \n        # Create transpose graph\n        transpose_edges = defaultdict(list)\n        for vertex in self.vertices:\n            for edge in self.edges[vertex]:\n                transpose_edges[edge.to].append(vertex)\n        \n        # Second DFS on transpose graph\n        visited.clear()\n        sccs = []\n        \n        def dfs2(vertex, component):\n            visited.add(vertex)\n            component.append(vertex)\n            for neighbor in transpose_edges[vertex]:\n                if neighbor not in visited:\n                    dfs2(neighbor, component)\n        \n        while finish_stack:\n            vertex = finish_stack.pop()\n            if vertex not in visited:\n                component = []\n                dfs2(vertex, component)\n                sccs.append(component)\n        \n        return sccs\n        \n    def minimum_spanning_tree(self) -> List[Tuple[str, str, float]]:\n        \"\"\"Minimum spanning tree using Kruskal's algorithm\"\"\"\n        if self.directed:\n            return []  # MST only for undirected graphs\n        \n        # Get all edges\n        all_edges = []\n        seen_edges = set()\n        \n        for vertex in self.vertices:\n            for edge in self.edges[vertex]:\n                edge_key = tuple(sorted([vertex, edge.to]))\n                if edge_key not in seen_edges:\n                    all_edges.append((vertex, edge.to, edge.weight))\n                    seen_edges.add(edge_key)\n        \n        # Sort edges by weight\n        all_edges.sort(key=lambda x: x[2])\n        \n        # Kruskal's algorithm\n        uf = UnionFind(self.vertices)\n        mst = []\n        \n        for u, v, weight in all_edges:\n            if uf.union(u, v):\n                mst.append((u, v, weight))\n                if len(mst) == len(self.vertices) - 1:\n                    break\n        \n        return mst\n        \n    def is_bipartite(self) -> Tuple[bool, Dict[str, int]]:\n        \"\"\"Check if graph is bipartite\"\"\"\n        coloring = {}\n        \n        def bfs_color(start):\n            queue = deque([start])\n            coloring[start] = 0\n            \n            while queue:\n                vertex = queue.popleft()\n                current_color = coloring[vertex]\n                \n                for edge in self.edges[vertex]:\n                    neighbor = edge.to\n                    if neighbor not in coloring:\n                        coloring[neighbor] = 1 - current_color\n                        queue.append(neighbor)\n                    elif coloring[neighbor] == current_color:\n                        return False\n            return True\n        \n        for vertex in self.vertices:\n            if vertex not in coloring:\n                if not bfs_color(vertex):\n                    return False, {}\n        \n        return True, coloring\n\n# Test the graph implementation\nif __name__ == \"__main__\":\n    # Test directed graph\n    g = Graph(directed=True)\n    \n    # Add edges\n    g.add_edge(\"A\", \"B\", 5)\n    g.add_edge(\"A\", \"C\", 3)\n    g.add_edge(\"B\", \"C\", 2)\n    g.add_edge(\"B\", \"D\", 4)\n    g.add_edge(\"C\", \"D\", 1)\n    \n    print(\"Graph created with vertices:\", g.vertices)\n    print(\"Edge count:\", g.edge_count)\n    \n    # Test Dijkstra's algorithm\n    distances = g.dijkstra(\"A\")\n    print(\"\\nDijkstra from A:\")\n    for vertex, (dist, path) in distances.items():\n        print(f\"  {vertex}: distance {dist}, path {' -> '.join(path)}\")\n    \n    # Test cycle detection\n    has_cycle = g.detect_cycle()\n    print(f\"\\nHas cycle: {has_cycle}\")\n    \n    # Test topological sort\n    if not has_cycle:\n        topo_order = g.topological_sort()\n        print(f\"Topological order: {' -> '.join(topo_order)}\")\n    \n    # Test undirected graph for MST\n    ug = Graph(directed=False)\n    ug.add_edge(\"A\", \"B\", 4)\n    ug.add_edge(\"A\", \"C\", 2)\n    ug.add_edge(\"B\", \"C\", 1)\n    ug.add_edge(\"B\", \"D\", 5)\n    ug.add_edge(\"C\", \"D\", 8)\n    ug.add_edge(\"C\", \"E\", 10)\n    ug.add_edge(\"D\", \"E\", 2)\n    \n    mst = ug.minimum_spanning_tree()\n    print(f\"\\nMinimum Spanning Tree:\")\n    total_weight = 0\n    for u, v, w in mst:\n        print(f\"  {u} - {v}: {w}\")\n        total_weight += w\n    print(f\"Total MST weight: {total_weight}\")\n    \n    # Test bipartite check\n    is_bip, coloring = ug.is_bipartite()\n    print(f\"\\nIs bipartite: {is_bip}\")\n    if is_bip:\n        print(\"Coloring:\", coloring)",
      "hints": [
        "Use heapq for Dijkstra's priority queue implementation",
        "Implement Union-Find for efficient MST construction",
        "Use BFS for finding augmenting paths in max flow",
        "Color vertices for cycle detection in directed graphs"
      ],
      "judge0Id": 71,
      "compilerType": "judge0"
    }
  },
  "testCases": [
    {
      "id": "test-dijkstra-paths",
      "input": "",
      "output": "Graph created with vertices: {'A', 'B', 'C', 'D'}\\nEdge count: 5\\n\\nDijkstra from A:\\n  A: distance 0, path A\\n  B: distance 5, path A -> B\\n  C: distance 3, path A -> C\\n  D: distance 4, path A -> C -> D\\n\\nHas cycle: False\\nTopological order: A -> C -> B -> D\\n\\nMinimum Spanning Tree:\\n  B - C: 1\\n  A - C: 2\\n  D - E: 2\\n  A - B: 4\\nTotal MST weight: 9\\n\\nIs bipartite: True\\nColoring: {'A': 0, 'C': 1, 'B': 1, 'E': 0, 'D': 0}",
      "points": 7,
      "isHidden": false,
      "timeout": 10000
    },
    {
      "id": "test-graph-properties",
      "input": "",
      "output": "Graph created with vertices: {'A', 'B', 'C', 'D'}\\nEdge count: 5",
      "points": 3,
      "isHidden": true,
      "timeout": 5000
    }
  ],
  "editorial": {
    "approach": "Advanced graph algorithms provide efficient solutions for pathfinding, network flow, and structural analysis problems through optimized data structures and algorithmic techniques.",
    "complexity": {
      "time": "O(V log V + E) for Dijkstra, O(VE) for Bellman-Ford, O(VÂ³) for Floyd-Warshall, O(E log E) for MST",
      "space": "O(V + E) for graph representation and auxiliary data structures"
    },
    "keyPoints": [
      "Priority queue optimization for shortest path algorithms",
      "Union-Find for efficient cycle detection and MST",
      "Ford-Fulkerson method for maximum flow computation",
      "Graph coloring for bipartite testing and scheduling"
    ]
  }
}