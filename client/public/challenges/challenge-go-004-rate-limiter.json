{
  "id": "go-rate-limiter",
  "metadata": {
    "title": "Token Bucket Rate Limiter",
    "description": "Implement a token bucket rate limiter to control API request rates.\n\n## Learning Objectives\n- Rate limiting algorithms\n- Time-based calculations\n- Concurrent safety with mutexes\n- Real-world API protection",
    "difficulty": "medium",
    "points": 2,
    "timeLimit": 20,
    "tags": ["go", "rate-limiting", "algorithms", "concurrency", "api"],
    "author": "Z-Challenge Team",
    "createdAt": "2025-10-05T10:15:00Z",
    "version": "1.0",
    "supportedLanguages": ["go"]
  },
  "problem": {
    "statement": "Implement a token bucket rate limiter that allows 5 requests per 10 seconds. Process a series of requests and return 'allowed' or 'denied' for each.",
    "inputFormat": "Number of requests followed by timestamps (seconds since start)",
    "outputFormat": "For each request: 'allowed' or 'denied'",
    "constraints": "- Bucket capacity: 5 tokens\n- Refill rate: 5 tokens per 10 seconds\n- Initial bucket is full",
    "examples": [
      {
        "input": "6\n0 1 2 3 4 15",
        "output": "allowed\nallowed\nallowed\nallowed\nallowed\nallowed",
        "explanation": "First 5 requests consume tokens, 6th request at t=15 gets refilled tokens"
      }
    ]
  },
  "languages": {
    "go": {
      "starterCode": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype TokenBucket struct {\n\tcapacity      int\n\ttokens        int\n\trefillRate    int\n\trefillPeriod  time.Duration\n\tlastRefill    time.Time\n\tmutex         sync.Mutex\n}\n\nfunc NewTokenBucket(capacity, refillRate int, refillPeriod time.Duration) *TokenBucket {\n\t// Your implementation here\n\treturn nil\n}\n\nfunc (tb *TokenBucket) Allow() bool {\n\t// Your implementation here\n\treturn false\n}\n\nfunc main() {\n\ttb := NewTokenBucket(5, 5, 10*time.Second)\n\t\n\tvar numRequests int\n\tfmt.Scan(&numRequests)\n\t\n\tfor i := 0; i < numRequests; i++ {\n\t\tvar timestamp int\n\t\tfmt.Scan(&timestamp)\n\t\t\n\t\t// Simulate time passage\n\t\ttime.Sleep(time.Duration(timestamp) * time.Second)\n\t\t\n\t\tif tb.Allow() {\n\t\t\tfmt.Println(\"allowed\")\n\t\t} else {\n\t\t\tfmt.Println(\"denied\")\n\t\t}\n\t}\n}",
      "solutionCode": "package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\ntype TokenBucket struct {\n\tcapacity      int\n\ttokens        int\n\trefillRate    int\n\trefillPeriod  time.Duration\n\tlastRefill    time.Time\n\tmutex         sync.Mutex\n}\n\nfunc NewTokenBucket(capacity, refillRate int, refillPeriod time.Duration) *TokenBucket {\n\treturn &TokenBucket{\n\t\tcapacity:     capacity,\n\t\ttokens:       capacity, // Start with full bucket\n\t\trefillRate:   refillRate,\n\t\trefillPeriod: refillPeriod,\n\t\tlastRefill:   time.Now(),\n\t}\n}\n\nfunc (tb *TokenBucket) Allow() bool {\n\ttb.mutex.Lock()\n\tdefer tb.mutex.Unlock()\n\t\n\tnow := time.Now()\n\ttimePassed := now.Sub(tb.lastRefill)\n\t\n\t// Calculate tokens to add based on time passed\n\tif timePassed >= tb.refillPeriod {\n\t\tperiodsElapsed := int(timePassed / tb.refillPeriod)\n\t\ttokensToAdd := periodsElapsed * tb.refillRate\n\t\ttb.tokens += tokensToAdd\n\t\t\n\t\tif tb.tokens > tb.capacity {\n\t\t\ttb.tokens = tb.capacity\n\t\t}\n\t\t\n\t\ttb.lastRefill = now\n\t}\n\t\n\t// Check if request can be allowed\n\tif tb.tokens > 0 {\n\t\ttb.tokens--\n\t\treturn true\n\t}\n\t\n\treturn false\n}\n\nvar startTime time.Time\n\nfunc main() {\n\tstartTime = time.Now()\n\ttb := NewTokenBucket(5, 5, 10*time.Second)\n\t\n\tvar numRequests int\n\tfmt.Scan(&numRequests)\n\t\n\tfor i := 0; i < numRequests; i++ {\n\t\tvar timestamp int\n\t\tfmt.Scan(&timestamp)\n\t\t\n\t\t// Simulate time passage by adjusting the bucket's last refill time\n\t\ttb.mutex.Lock()\n\t\ttb.lastRefill = startTime.Add(time.Duration(timestamp) * time.Second)\n\t\ttb.mutex.Unlock()\n\t\t\n\t\tif tb.Allow() {\n\t\t\tfmt.Println(\"allowed\")\n\t\t} else {\n\t\t\tfmt.Println(\"denied\")\n\t\t}\n\t}\n}",
      "hints": [
        "Track tokens, capacity, and last refill time",
        "Calculate elapsed time to determine token refill",
        "Use mutex for thread safety",
        "Consume a token when allowing a request"
      ],
      "judge0Id": 95,
      "compilerType": "judge0"
    }
  },
  "testCases": [
    {
      "id": "test-basic",
      "input": "6\n0 1 2 3 4 15",
      "output": "allowed\nallowed\nallowed\nallowed\nallowed\nallowed",
      "points": 5,
      "isHidden": false,
      "timeout": 3000
    },
    {
      "id": "test-overflow",
      "input": "7\n0 1 2 3 4 5 6",
      "output": "allowed\nallowed\nallowed\nallowed\nallowed\ndenied\ndenied",
      "points": 3,
      "isHidden": false,
      "timeout": 3000
    },
    {
      "id": "test-refill",
      "input": "3\n0 10 11",
      "output": "allowed\nallowed\nallowed",
      "points": 2,
      "isHidden": true,
      "timeout": 3000
    }
  ],
  "editorial": {
    "approach": "Token bucket algorithm maintains a bucket of tokens that refill at a constant rate. Each request consumes a token if available.",
    "complexity": {
      "time": "O(1) per request",
      "space": "O(1)"
    },
    "keyPoints": [
      "Token bucket maintains capacity and current tokens",
      "Refill tokens based on elapsed time",
      "Thread safety with mutex for concurrent access",
      "Rate limiting prevents system overload"
    ]
  }
}